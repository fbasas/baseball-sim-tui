---
phase: 01-data-foundation-simulation-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/simulation/__init__.py
  - src/simulation/odds_ratio.py
  - src/simulation/league_averages.py
  - tests/test_odds_ratio.py
autonomous: true

must_haves:
  truths:
    - "Odds-ratio calculation produces correct probability for two-way matchups"
    - "Elite pitcher vs weak hitter produces appropriately skewed probability (not naive average)"
    - "League averages exist for each era (deadball, liveball, modern)"
    - "Probability normalization ensures all outcomes sum to 1.0"
  artifacts:
    - path: "src/simulation/odds_ratio.py"
      provides: "Odds-ratio probability calculation"
      exports: ["calculate_odds_ratio", "calculate_matchup_probabilities"]
    - path: "src/simulation/league_averages.py"
      provides: "Era-specific league average statistics"
      exports: ["get_league_averages", "get_era"]
    - path: "tests/test_odds_ratio.py"
      provides: "Mathematical validation of odds-ratio method"
      contains: "def test_"
  key_links:
    - from: "src/simulation/odds_ratio.py"
      to: "probability math"
      via: "odds = prob / (1 - prob)"
      pattern: "batter_prob.*1.*-.*batter_prob"
    - from: "src/simulation/odds_ratio.py"
      to: "src/simulation/league_averages.py"
      via: "uses league context"
      pattern: "league_prob"
---

<objective>
Implement the odds-ratio method for combining pitcher, batter, and league probabilities into accurate matchup probabilities.

Purpose: This is the mathematical core that prevents the "naive averaging" pitfall. Getting this wrong invalidates all simulation results.
Output: Functions that correctly combine probabilities using the odds-ratio formula, with era-appropriate league averages.
</objective>

<execution_context>
@/home/fbasas/.claude/get-shit-done/workflows/execute-plan.md
@/home/fbasas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation-simulation-core/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create league averages module</name>
  <files>
    - src/simulation/__init__.py
    - src/simulation/league_averages.py
  </files>
  <action>
Create the simulation package structure:
```
src/
    simulation/
        __init__.py
        league_averages.py
```

In `league_averages.py`, define era-specific league average probabilities based on RESEARCH.md.

Create dictionary `LEAGUE_AVERAGES` with three eras:
- `deadball` (1901-1919): Lower power, fewer strikeouts
- `liveball` (1920-1960): More offense, moderate strikeouts
- `modern` (1961-present): High strikeouts, more home runs

Each era contains probabilities per plate appearance for:
- strikeout, walk, hbp, single, double, triple, home_run
- Also include: groundout, flyout, lineout (as remainder of outs)

From RESEARCH.md, approximate values:
```python
LEAGUE_AVERAGES = {
    'deadball': {  # 1901-1919
        'strikeout': 0.10, 'walk': 0.08, 'hbp': 0.008,
        'single': 0.18, 'double': 0.04, 'triple': 0.02, 'home_run': 0.005,
    },
    'liveball': {  # 1920-1960
        'strikeout': 0.12, 'walk': 0.09, 'hbp': 0.008,
        'single': 0.17, 'double': 0.04, 'triple': 0.015, 'home_run': 0.02,
    },
    'modern': {  # 1961-present
        'strikeout': 0.21, 'walk': 0.08, 'hbp': 0.01,
        'single': 0.15, 'double': 0.045, 'triple': 0.005, 'home_run': 0.03,
    },
}
```

Create helper functions:
1. `get_era(year: int) -> str` - Return era name for year
   - year < 1920: 'deadball'
   - 1920 <= year < 1961: 'liveball'
   - year >= 1961: 'modern'

2. `get_league_averages(year: int) -> dict` - Return league averages for the year's era

3. `calculate_out_rate(averages: dict) -> float` - Calculate implied out rate
   - out_rate = 1 - (sum of all positive outcome probabilities)
  </action>
  <verify>
Run `python -c "from src.simulation.league_averages import get_league_averages, get_era; print(get_era(1927), get_league_averages(2023))"` shows 'liveball' and modern era dict.
  </verify>
  <done>League averages module returns era-appropriate baseline probabilities.</done>
</task>

<task type="auto">
  <name>Task 2: Implement odds-ratio calculation</name>
  <files>src/simulation/odds_ratio.py</files>
  <action>
Implement the odds-ratio formula from RESEARCH.md. This is the mathematical core of the simulation.

The odds-ratio formula:
```
Odds = probability / (1 - probability)
Matchup_Odds = (Batter_Odds * Pitcher_Odds) / League_Odds
Result = Matchup_Odds / (1 + Matchup_Odds)
```

Create functions:

1. `probability_to_odds(prob: float) -> float`
   - Convert probability to odds ratio
   - Handle edge cases: prob=0 returns 0, prob=1 returns float('inf')
   - Raise ValueError if prob < 0 or prob > 1

2. `odds_to_probability(odds: float) -> float`
   - Convert odds back to probability
   - Handle infinity: returns 1.0
   - Formula: odds / (1 + odds)

3. `calculate_odds_ratio(batter_prob: float, pitcher_prob: float, league_prob: float) -> float`
   - Combine three probabilities using odds-ratio method
   - Handle edge cases for 0 and 1 probabilities
   - Validate league_prob is strictly between 0 and 1

4. `calculate_matchup_probabilities(batter_probs: dict, pitcher_probs: dict, league_probs: dict) -> dict`
   - Apply odds-ratio to each event type
   - Events: strikeout, walk, hbp, single, double, triple, home_run
   - Return unnormalized probabilities (caller may normalize)

5. `normalize_probabilities(probs: dict) -> dict`
   - Scale probabilities so they sum to 1.0
   - Return new dict with normalized values

Key insight from RESEARCH.md: Do NOT simply average batter and pitcher rates. A 47% K pitcher vs 31% K batter should NOT produce 39% K rate. The odds-ratio method properly handles the multiplicative interaction.

Example from RESEARCH.md:
- Batter K rate: 0.20 (below average)
- Pitcher K rate: 0.25 (above average)
- League K rate: 0.21
- Naive average: 0.225 (WRONG)
- Odds-ratio: ~0.238 (correctly reflects pitcher advantage)
  </action>
  <verify>
Run `python -c "from src.simulation.odds_ratio import calculate_odds_ratio; print(calculate_odds_ratio(0.20, 0.25, 0.21))"` - should be approximately 0.238.
  </verify>
  <done>Odds-ratio functions correctly combine probabilities, avoiding naive averaging pitfall.</done>
</task>

<task type="auto">
  <name>Task 3: Create odds-ratio tests</name>
  <files>tests/test_odds_ratio.py</files>
  <action>
Create comprehensive tests for the odds-ratio math. These tests validate the mathematical correctness of the simulation core.

Test cases:

1. `test_probability_to_odds_basic()`:
   - prob=0.5 -> odds=1.0
   - prob=0.25 -> odds=0.333...
   - prob=0.75 -> odds=3.0

2. `test_odds_to_probability_basic()`:
   - odds=1.0 -> prob=0.5
   - odds=0 -> prob=0
   - odds=inf -> prob=1.0

3. `test_odds_ratio_returns_league_when_both_average()`:
   - If batter and pitcher both match league average, result should equal league average
   - calculate_odds_ratio(0.21, 0.21, 0.21) == 0.21

4. `test_odds_ratio_elite_pitcher_dominates_weak_hitter()`:
   - Elite K pitcher (0.30) vs weak contact hitter (0.25)
   - League K rate (0.21)
   - Result should be HIGHER than naive average of 0.275
   - This is the critical test - it proves we're not naive averaging

5. `test_odds_ratio_weak_pitcher_dominated_by_elite_hitter()`:
   - Weak K pitcher (0.15) vs elite contact hitter (0.10)
   - League K rate (0.21)
   - Result should be LOWER than naive average

6. `test_normalize_probabilities()`:
   - Input: {a: 0.3, b: 0.4, c: 0.5} (sum=1.2)
   - Output should sum to 1.0
   - Ratios preserved: a/b should be same before and after

7. `test_matchup_probabilities_structure()`:
   - calculate_matchup_probabilities returns dict with expected keys
   - All values are floats between 0 and 1

8. `test_edge_cases()`:
   - prob=0 and prob=1 don't crash
   - Validation errors raised for invalid inputs

Use pytest and approximate comparisons (pytest.approx) for floating point.
  </action>
  <verify>
Run `pytest tests/test_odds_ratio.py -v` - all tests pass.
  </verify>
  <done>Odds-ratio tests validate mathematical correctness and edge cases.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.simulation import odds_ratio, league_averages; print('Imports OK')"` - Modules importable
2. `pytest tests/test_odds_ratio.py -v` - All tests pass
3. Manual check: `calculate_odds_ratio(0.30, 0.15, 0.21)` should be > 0.225 (not naive average)
4. Manual check: League averages for each era sum to < 1.0 (leaving room for outs)
</verification>

<success_criteria>
- Odds-ratio formula correctly implemented per RESEARCH.md
- Elite matchups produce appropriately skewed results (not naive averages)
- League averages cover three eras with reasonable values
- All probabilities validated (0-1 range)
- Tests prove mathematical correctness
- normalize_probabilities produces sum of 1.0
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation-simulation-core/01-02-SUMMARY.md`
</output>
