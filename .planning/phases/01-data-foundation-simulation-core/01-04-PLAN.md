---
phase: 01-data-foundation-simulation-core
plan: 04
type: execute
wave: 2
depends_on: ["01-03"]
files_modified:
  - src/simulation/advancement.py
  - src/simulation/game_state.py
  - tests/test_advancement.py
autonomous: true

must_haves:
  truths:
    - "Runner advancement returns new base state after any outcome"
    - "Home run clears all bases and scores all runners plus batter"
    - "Single with runner on second sometimes scores, sometimes holds at third"
    - "Advancement probabilities derived from historical data"
  artifacts:
    - path: "src/simulation/advancement.py"
      provides: "Runner advancement logic with probability matrices"
      exports: ["advance_runners", "SINGLE_ADVANCEMENT", "DOUBLE_ADVANCEMENT"]
    - path: "src/simulation/game_state.py"
      provides: "BaseState representation and manipulation"
      exports: ["BaseState"]
    - path: "tests/test_advancement.py"
      provides: "Tests for runner advancement"
      contains: "def test_"
  key_links:
    - from: "src/simulation/advancement.py"
      to: "src/simulation/outcomes.py"
      via: "uses AtBatOutcome to determine advancement"
      pattern: "AtBatOutcome\\."
    - from: "src/simulation/advancement.py"
      to: "src/simulation/rng.py"
      via: "uses RNG for probabilistic advancement"
      pattern: "rng\\.random\\(\\)|rng\\.choice\\("
---

<objective>
Implement runner advancement logic that moves baserunners appropriately based on at-bat outcomes.

Purpose: After determining the at-bat outcome, we need to know who scores and where runners end up. This uses probability matrices derived from historical play-by-play data.
Output: Function that takes current base state and at-bat outcome, returns new base state and runs scored.
</objective>

<execution_context>
@/home/fbasas/.claude/get-shit-done/workflows/execute-plan.md
@/home/fbasas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation-simulation-core/01-RESEARCH.md
@.planning/phases/01-data-foundation-simulation-core/01-03-SUMMARY.md (if exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base state representation</name>
  <files>src/simulation/game_state.py</files>
  <action>
Create a simple base state representation. This will be expanded in Phase 2 for full game state; for now just track bases.

```python
from dataclasses import dataclass, field
from typing import Optional, Tuple

@dataclass
class BaseState:
    """Represents runners on base.

    Uses Optional[str] for player IDs on each base.
    None means base is empty.
    """
    first: Optional[str] = None   # Player ID on first, or None
    second: Optional[str] = None  # Player ID on second, or None
    third: Optional[str] = None   # Player ID on third, or None

    @property
    def is_empty(self) -> bool:
        return self.first is None and self.second is None and self.third is None

    @property
    def runners_on(self) -> Tuple[bool, bool, bool]:
        """Return (on_first, on_second, on_third) booleans."""
        return (self.first is not None, self.second is not None, self.third is not None)

    @property
    def count(self) -> int:
        """Number of runners on base."""
        return sum(1 for r in [self.first, self.second, self.third] if r is not None)

    def as_tuple(self) -> Tuple[bool, bool, bool]:
        """Return base state as boolean tuple for lookup in advancement matrices."""
        return self.runners_on

    @classmethod
    def from_tuple(cls, runners: Tuple[bool, bool, bool], player_ids: Tuple[str, str, str] = ('R1', 'R2', 'R3')) -> 'BaseState':
        """Create BaseState from boolean tuple. Uses generic IDs if not specified."""
        return cls(
            first=player_ids[0] if runners[0] else None,
            second=player_ids[1] if runners[1] else None,
            third=player_ids[2] if runners[2] else None
        )

    def clear(self) -> 'BaseState':
        """Return new empty base state."""
        return BaseState()

    def __repr__(self) -> str:
        bases = []
        if self.first: bases.append("1B")
        if self.second: bases.append("2B")
        if self.third: bases.append("3B")
        return f"BaseState({', '.join(bases) if bases else 'empty'})"
```

Also create a simple result class for advancement:

```python
@dataclass
class AdvancementResult:
    """Result of runner advancement."""
    new_base_state: BaseState
    runs_scored: int
    runners_scored: list  # List of player IDs who scored

    @property
    def batter_safe(self) -> bool:
        """Did the batter reach base (or score)?"""
        # Check if batter is somewhere on bases or scored
        return True  # Simplified - batter always reaches on positive outcomes
```
  </action>
  <verify>
Run `python -c "from src.simulation.game_state import BaseState; bs = BaseState(first='ruth01', second='gehrig01'); print(bs.count, bs.as_tuple())"` shows 2 (True, True, False).
  </verify>
  <done>BaseState dataclass represents runner positions with helper properties.</done>
</task>

<task type="auto">
  <name>Task 2: Create advancement matrices and logic</name>
  <files>src/simulation/advancement.py</files>
  <action>
Implement runner advancement using probability matrices from RESEARCH.md Pattern 4.

Create advancement matrices for each outcome type. These are based on historical Retrosheet data.

Matrix structure:
- Key: tuple of (first, second, third) booleans
- Value: list of (new_state_tuple, runs_scored, probability) tuples

```python
from typing import Dict, List, Tuple
from .outcomes import AtBatOutcome
from .game_state import BaseState, AdvancementResult
from .rng import SimulationRNG

# Type aliases
BaseStateTuple = Tuple[bool, bool, bool]
AdvancementOption = Tuple[BaseStateTuple, int, float]  # (new_state, runs, probability)
AdvancementMatrix = Dict[BaseStateTuple, List[AdvancementOption]]

# Single advancement - batter to first, runners advance probabilistically
SINGLE_ADVANCEMENT: AdvancementMatrix = {
    # Empty bases - batter to first
    (False, False, False): [((True, False, False), 0, 1.0)],

    # Runner on first - most advance to third, some stay at second
    (True, False, False): [
        ((True, True, False), 0, 0.70),   # Runner holds at 2nd
        ((True, False, True), 0, 0.30),   # Runner advances to 3rd
    ],

    # Runner on second - scores or holds at third
    (False, True, False): [
        ((True, False, False), 1, 0.60),  # Scores
        ((True, False, True), 0, 0.40),   # Holds at 3rd
    ],

    # Runner on third - always scores
    (False, False, True): [((True, False, False), 1, 1.0)],

    # Runners on first and second
    (True, True, False): [
        ((True, True, False), 1, 0.35),   # Lead runner scores, trail to 2nd
        ((True, False, True), 1, 0.25),   # Lead scores, trail to 3rd
        ((True, True, True), 0, 0.40),    # Both advance, none score
    ],

    # Runners on first and third
    (True, False, True): [
        ((True, True, False), 1, 0.70),   # 3rd scores, 1st to 2nd
        ((True, False, True), 1, 0.30),   # 3rd scores, 1st to 3rd
    ],

    # Runners on second and third
    (False, True, True): [
        ((True, False, False), 2, 0.60),  # Both score
        ((True, False, True), 1, 0.40),   # 3rd scores, 2nd holds
    ],

    # Bases loaded
    (True, True, True): [
        ((True, True, False), 2, 0.35),   # 2 score
        ((True, True, True), 1, 0.45),    # 1 scores
        ((True, False, True), 2, 0.20),   # 2 score, batter to 1st, runner to 3rd
    ],
}

# Double advancement - batter to second
DOUBLE_ADVANCEMENT: AdvancementMatrix = {
    (False, False, False): [((False, True, False), 0, 1.0)],
    (True, False, False): [
        ((False, True, False), 1, 0.60),  # Runner scores
        ((False, True, True), 0, 0.40),   # Runner to 3rd
    ],
    (False, True, False): [((False, True, False), 1, 1.0)],  # Scores
    (False, False, True): [((False, True, False), 1, 1.0)],  # Scores
    (True, True, False): [((False, True, False), 2, 0.70), ((False, True, True), 1, 0.30)],
    (True, False, True): [((False, True, False), 2, 0.85), ((False, True, True), 1, 0.15)],
    (False, True, True): [((False, True, False), 2, 1.0)],
    (True, True, True): [((False, True, False), 3, 0.75), ((False, True, True), 2, 0.25)],
}

# Triple advancement - batter to third, everyone scores
TRIPLE_ADVANCEMENT: AdvancementMatrix = {
    (False, False, False): [((False, False, True), 0, 1.0)],
    (True, False, False): [((False, False, True), 1, 1.0)],
    (False, True, False): [((False, False, True), 1, 1.0)],
    (False, False, True): [((False, False, True), 1, 1.0)],
    (True, True, False): [((False, False, True), 2, 1.0)],
    (True, False, True): [((False, False, True), 2, 1.0)],
    (False, True, True): [((False, False, True), 2, 1.0)],
    (True, True, True): [((False, False, True), 3, 1.0)],
}

# Walk advancement - force runners only
WALK_ADVANCEMENT: AdvancementMatrix = {
    (False, False, False): [((True, False, False), 0, 1.0)],
    (True, False, False): [((True, True, False), 0, 1.0)],
    (False, True, False): [((True, True, False), 0, 1.0)],
    (False, False, True): [((True, False, True), 0, 1.0)],
    (True, True, False): [((True, True, True), 0, 1.0)],
    (True, False, True): [((True, True, True), 0, 1.0)],
    (False, True, True): [((True, True, True), 0, 1.0)],
    (True, True, True): [((True, True, True), 1, 1.0)],  # Force scores run
}
```

Create the main advancement function:

```python
def advance_runners(
    base_state: BaseState,
    outcome: AtBatOutcome,
    rng: SimulationRNG,
    batter_id: str = 'batter'
) -> AdvancementResult:
    """
    Advance runners based on at-bat outcome.

    Returns AdvancementResult with new base state and runs scored.
    """
    # Home run - everyone scores
    if outcome == AtBatOutcome.HOME_RUN:
        runs = base_state.count + 1  # All runners plus batter
        return AdvancementResult(
            new_base_state=BaseState(),
            runs_scored=runs,
            runners_scored=[...]  # All previous runners + batter
        )

    # Select appropriate matrix
    if outcome in (AtBatOutcome.SINGLE, AtBatOutcome.INFIELD_SINGLE):
        matrix = SINGLE_ADVANCEMENT
    elif outcome == AtBatOutcome.DOUBLE:
        matrix = DOUBLE_ADVANCEMENT
    elif outcome == AtBatOutcome.TRIPLE:
        matrix = TRIPLE_ADVANCEMENT
    elif outcome in (AtBatOutcome.WALK, AtBatOutcome.HIT_BY_PITCH):
        matrix = WALK_ADVANCEMENT
    elif outcome.is_out:
        # Outs don't advance runners (simplified - no sac fly yet)
        return AdvancementResult(
            new_base_state=base_state,  # Unchanged
            runs_scored=0,
            runners_scored=[]
        )
    else:
        # Default - no advancement
        return AdvancementResult(base_state, 0, [])

    # Look up options for current base state
    state_tuple = base_state.as_tuple()
    options = matrix.get(state_tuple, [((True, False, False), 0, 1.0)])

    # Probabilistically select outcome
    if len(options) == 1:
        new_state, runs, _ = options[0]
    else:
        probs = [opt[2] for opt in options]
        idx = rng.choice(list(range(len(options))), probs)
        new_state, runs, _ = options[idx]

    return AdvancementResult(
        new_base_state=BaseState.from_tuple(new_state),
        runs_scored=runs,
        runners_scored=[]  # Simplified - tracking IDs deferred
    )
```
  </action>
  <verify>
Run `python -c "from src.simulation.advancement import advance_runners, SINGLE_ADVANCEMENT; from src.simulation.game_state import BaseState; from src.simulation.outcomes import AtBatOutcome; from src.simulation.rng import SimulationRNG; bs = BaseState(second='runner'); rng = SimulationRNG(42); result = advance_runners(bs, AtBatOutcome.SINGLE, rng); print(result.runs_scored, result.new_base_state)"` - should show possible scoring.
  </verify>
  <done>Advancement matrices cover all base states for singles, doubles, triples, walks. Main function selects probabilistically.</done>
</task>

<task type="auto">
  <name>Task 3: Create advancement tests</name>
  <files>tests/test_advancement.py</files>
  <action>
Create tests for runner advancement logic.

Test cases:

1. `test_home_run_clears_bases()`:
   - Bases loaded, home run
   - Result: empty bases, 4 runs scored

2. `test_home_run_solo()`:
   - Empty bases, home run
   - Result: empty bases, 1 run scored

3. `test_single_runner_on_second_sometimes_scores()`:
   - Runner on second, single
   - Run 100 times: should have mix of 0 and 1 runs scored
   - Verifies probabilistic nature

4. `test_walk_forces_runners()`:
   - Bases loaded, walk
   - Result: bases still loaded, 1 run scored (forced)

5. `test_walk_no_force_no_advance()`:
   - Runner on second only, walk
   - Result: runners on first and second, 0 runs

6. `test_triple_everyone_scores()`:
   - Runners on first and second, triple
   - Result: runner on third only, 2 runs scored

7. `test_out_no_advancement()`:
   - Runner on first, groundout
   - Result: runner still on first (simplified model)

8. `test_double_runner_on_first()`:
   - Runner on first, double
   - Runner should score or go to third (probabilistic)

9. `test_reproducible_with_seed()`:
   - Same seed produces same advancement decisions

10. `test_all_base_states_covered()`:
    - Each of 8 base states has entry in SINGLE_ADVANCEMENT
    - No KeyError when looking up any state
  </action>
  <verify>
Run `pytest tests/test_advancement.py -v` - all tests pass.
  </verify>
  <done>Advancement tests validate deterministic and probabilistic behavior.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.simulation.advancement import advance_runners; print('Import OK')"` - Module importable
2. `pytest tests/test_advancement.py -v` - All tests pass
3. Manual: Home run with bases loaded produces 4 runs
4. Manual: Walk with bases loaded forces 1 run
5. Manual: Single with runner on second produces mix of outcomes over many trials
</verification>

<success_criteria>
- BaseState tracks runners with helper properties
- Advancement matrices cover all 8 base states for each outcome type
- Home runs always clear bases and score everyone
- Walks only force runners (no extra advancement)
- Probabilistic outcomes (single with runner on second) produce realistic mix
- Same seed produces identical advancement decisions
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation-simulation-core/01-04-SUMMARY.md`
</output>
