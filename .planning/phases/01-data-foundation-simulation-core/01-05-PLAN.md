---
phase: 01-data-foundation-simulation-core
plan: 05
type: execute
wave: 3
depends_on: ["01-01", "01-03", "01-04"]
files_modified:
  - src/simulation/engine.py
  - src/simulation/stats_calculator.py
  - tests/test_engine.py
  - tests/test_validation.py
autonomous: true

must_haves:
  truths:
    - "Engine simulates at-bat between pitcher and batter using their stats"
    - "1000-game simulation produces batting averages within 10% of historical"
    - "Elite pitcher vs weak hitter produces lower BA than naive average"
    - "Simulation returns probability breakdown and audit trail"
  artifacts:
    - path: "src/simulation/engine.py"
      provides: "Main simulation engine orchestrating at-bat"
      exports: ["SimulationEngine", "AtBatResult"]
    - path: "src/simulation/stats_calculator.py"
      provides: "Calculate probabilities from player stats"
      exports: ["calculate_batter_probabilities", "calculate_pitcher_probabilities"]
    - path: "tests/test_engine.py"
      provides: "Integration tests for simulation engine"
      contains: "def test_"
    - path: "tests/test_validation.py"
      provides: "Statistical validation tests"
      contains: "def test_"
  key_links:
    - from: "src/simulation/engine.py"
      to: "src/simulation/odds_ratio.py"
      via: "combines probabilities"
      pattern: "calculate_matchup_probabilities"
    - from: "src/simulation/engine.py"
      to: "src/simulation/at_bat.py"
      via: "resolves outcomes"
      pattern: "resolve_at_bat"
    - from: "src/simulation/engine.py"
      to: "src/simulation/advancement.py"
      via: "advances runners"
      pattern: "advance_runners"
    - from: "src/simulation/engine.py"
      to: "src/data/lahman.py"
      via: "loads player stats"
      pattern: "repository"
---

<objective>
Create the simulation engine that orchestrates all components and validate it produces statistically accurate results.

Purpose: This is the integration point that combines data loading, probability calculation, outcome resolution, and runner advancement into a complete at-bat simulation. Validation proves the simulation matches historical patterns.
Output: Working simulation engine that can simulate at-bats and validate against historical statistics.
</objective>

<execution_context>
@/home/fbasas/.claude/get-shit-done/workflows/execute-plan.md
@/home/fbasas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation-simulation-core/01-RESEARCH.md
@.planning/phases/01-data-foundation-simulation-core/01-01-SUMMARY.md (if exists)
@.planning/phases/01-data-foundation-simulation-core/01-03-SUMMARY.md (if exists)
@.planning/phases/01-data-foundation-simulation-core/01-04-SUMMARY.md (if exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stats calculator</name>
  <files>src/simulation/stats_calculator.py</files>
  <action>
Create functions to convert raw player statistics into event probabilities.

The key is calculating rates per plate appearance, not per at-bat (since walks/HBP don't count as AB).

```python
from typing import Dict, Optional
from ..data.models import BattingStats, PitchingStats
from .league_averages import get_league_averages

def calculate_batter_probabilities(stats: BattingStats, year: int) -> Dict[str, float]:
    """
    Convert batting stats to event probabilities per plate appearance.

    Returns dict with keys: strikeout, walk, hbp, single, double, triple, home_run
    """
    pa = stats.plate_appearances
    if pa == 0:
        # No stats - return league average for era
        return get_league_averages(year)

    return {
        'strikeout': stats.strikeouts / pa,
        'walk': stats.walks / pa,
        'hbp': stats.hit_by_pitch / pa if stats.hit_by_pitch else 0,
        'single': stats.singles / pa,
        'double': stats.doubles / pa,
        'triple': stats.triples / pa,
        'home_run': stats.home_runs / pa,
    }


def calculate_pitcher_probabilities(stats: PitchingStats, year: int) -> Dict[str, float]:
    """
    Convert pitching stats to event probabilities per batter faced.

    Note: Pitching stats track what pitchers ALLOW, so these are opponent rates.
    """
    bf = stats.batters_faced
    if bf == 0:
        return get_league_averages(year)

    # Calculate hits allowed breakdown
    # Lahman only has total hits allowed, not breakdown
    # Use league ratios to estimate single/double/triple from total hits
    league = get_league_averages(year)
    total_hit_rate = league['single'] + league['double'] + league['triple'] + league['home_run']

    hits_allowed = stats.hits_allowed
    hr_allowed = stats.home_runs_allowed

    # Non-HR hits allocated by league ratios
    non_hr_hits = hits_allowed - hr_allowed
    non_hr_total = league['single'] + league['double'] + league['triple']

    if non_hr_total > 0:
        single_rate = (league['single'] / non_hr_total) * (non_hr_hits / bf)
        double_rate = (league['double'] / non_hr_total) * (non_hr_hits / bf)
        triple_rate = (league['triple'] / non_hr_total) * (non_hr_hits / bf)
    else:
        single_rate = double_rate = triple_rate = 0

    return {
        'strikeout': stats.strikeouts / bf,
        'walk': stats.walks_allowed / bf,
        'hbp': stats.hit_batters / bf if stats.hit_batters else 0,
        'single': single_rate,
        'double': double_rate,
        'triple': triple_rate,
        'home_run': hr_allowed / bf,
    }


def apply_park_factor(probs: Dict[str, float], park_factor: int) -> Dict[str, float]:
    """
    Adjust probabilities for park effects.

    Park factor of 100 = neutral. 110 = 10% more offense. 90 = 10% less.
    Apply at 50% since players play half games away.
    """
    if park_factor == 100:
        return probs.copy()

    # Park factor affects hits, especially HR and doubles
    adjustment = 1 + ((park_factor - 100) / 100) * 0.5  # Half effect

    adjusted = probs.copy()
    for event in ['single', 'double', 'triple', 'home_run']:
        adjusted[event] = probs[event] * adjustment

    return adjusted
```
  </action>
  <verify>
Run `python -c "from src.simulation.stats_calculator import calculate_batter_probabilities; from src.data.models import BattingStats; stats = BattingStats('ruth01', 1927, 'NYA', 151, 540, 158, 192, 29, 8, 60, 164, 7, 6, 137, 89, 0, 0, 0, 5); probs = calculate_batter_probabilities(stats, 1927); print(probs['home_run'])"` - should show ~0.09 (60 HR in ~680 PA).
  </verify>
  <done>Stats calculator converts raw statistics to probabilities, handles missing data with league averages.</done>
</task>

<task type="auto">
  <name>Task 2: Create simulation engine</name>
  <files>src/simulation/engine.py</files>
  <action>
Create the main simulation engine that orchestrates all components.

```python
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from ..data.models import BattingStats, PitchingStats
from ..data.lahman import LahmanRepository
from .odds_ratio import calculate_matchup_probabilities, normalize_probabilities
from .league_averages import get_league_averages
from .stats_calculator import calculate_batter_probabilities, calculate_pitcher_probabilities, apply_park_factor
from .at_bat import calculate_conditional_probabilities, resolve_at_bat
from .outcomes import AtBatOutcome
from .advancement import advance_runners
from .game_state import BaseState, AdvancementResult
from .rng import SimulationRNG


@dataclass
class AtBatResult:
    """Complete result of an at-bat simulation."""
    outcome: AtBatOutcome
    advancement: AdvancementResult
    probabilities: Dict[str, float]  # Matchup probabilities used
    audit_trail: List[tuple]         # RNG decisions

    @property
    def runs_scored(self) -> int:
        return self.advancement.runs_scored

    @property
    def is_hit(self) -> bool:
        return self.outcome.is_hit

    @property
    def is_out(self) -> bool:
        return self.outcome.is_out


class SimulationEngine:
    """
    Main simulation engine for at-bat resolution.

    Orchestrates:
    - Loading player statistics
    - Calculating matchup probabilities (odds-ratio)
    - Resolving at-bat outcomes (chained binomial)
    - Advancing runners
    """

    def __init__(
        self,
        repository: Optional[LahmanRepository] = None,
        rng: Optional[SimulationRNG] = None
    ):
        self.repository = repository
        self.rng = rng or SimulationRNG()

    def simulate_at_bat(
        self,
        batter_stats: BattingStats,
        pitcher_stats: PitchingStats,
        base_state: Optional[BaseState] = None,
        year: int = None,
        park_factor: int = 100
    ) -> AtBatResult:
        """
        Simulate a single at-bat.

        Args:
            batter_stats: Batter's season statistics
            pitcher_stats: Pitcher's season statistics
            base_state: Current runners on base (default: empty)
            year: Year for league averages (default: from batter_stats)
            park_factor: Park factor (100 = neutral)

        Returns:
            AtBatResult with outcome, advancement, probabilities, and audit trail
        """
        # Default values
        if base_state is None:
            base_state = BaseState()
        if year is None:
            year = batter_stats.year

        # Clear RNG audit trail for this at-bat
        initial_trail_length = len(self.rng.history)

        # Step 1: Calculate probabilities
        batter_probs = calculate_batter_probabilities(batter_stats, year)
        pitcher_probs = calculate_pitcher_probabilities(pitcher_stats, year)
        league_probs = get_league_averages(year)

        # Apply park factor to batter (home player)
        batter_probs = apply_park_factor(batter_probs, park_factor)

        # Step 2: Combine using odds-ratio
        matchup_probs = calculate_matchup_probabilities(
            batter_probs, pitcher_probs, league_probs
        )
        matchup_probs = normalize_probabilities(matchup_probs)

        # Step 3: Calculate conditional probabilities for decision tree
        game_situation = {
            'outs': 0,  # Simplified - full tracking in Phase 2
            'runners': base_state.runners_on,
        }
        conditional_probs = calculate_conditional_probabilities(matchup_probs, game_situation)

        # Step 4: Resolve outcome
        outcome = resolve_at_bat(conditional_probs, self.rng, game_situation)

        # Step 5: Advance runners
        advancement = advance_runners(
            base_state, outcome, self.rng, batter_stats.player_id
        )

        # Extract audit trail for this at-bat only
        audit_trail = self.rng.history[initial_trail_length:]

        return AtBatResult(
            outcome=outcome,
            advancement=advancement,
            probabilities=matchup_probs,
            audit_trail=audit_trail
        )

    def simulate_at_bat_from_ids(
        self,
        batter_id: str,
        batter_year: int,
        pitcher_id: str,
        pitcher_year: int,
        base_state: Optional[BaseState] = None,
        park_factor: int = 100
    ) -> Optional[AtBatResult]:
        """
        Simulate at-bat by loading stats from repository.

        Returns None if player stats not found.
        """
        if self.repository is None:
            raise ValueError("Repository required for ID-based simulation")

        batter_stats = self.repository.get_batting_stats(batter_id, batter_year)
        pitcher_stats = self.repository.get_pitching_stats(pitcher_id, pitcher_year)

        if batter_stats is None or pitcher_stats is None:
            return None

        return self.simulate_at_bat(
            batter_stats, pitcher_stats, base_state,
            year=batter_year, park_factor=park_factor
        )

    def get_expected_probabilities(
        self,
        batter_stats: BattingStats,
        pitcher_stats: PitchingStats,
        year: int = None,
        park_factor: int = 100
    ) -> Dict[str, float]:
        """
        Get matchup probabilities without simulating (no RNG).

        Useful for displaying expected outcomes before at-bat.
        """
        if year is None:
            year = batter_stats.year

        batter_probs = calculate_batter_probabilities(batter_stats, year)
        pitcher_probs = calculate_pitcher_probabilities(pitcher_stats, year)
        league_probs = get_league_averages(year)

        batter_probs = apply_park_factor(batter_probs, park_factor)

        matchup_probs = calculate_matchup_probabilities(
            batter_probs, pitcher_probs, league_probs
        )
        return normalize_probabilities(matchup_probs)

    def reset_rng(self, seed: int = None):
        """Reset RNG with new seed."""
        self.rng.reset(seed)
```
  </action>
  <verify>
Run `python -c "from src.simulation.engine import SimulationEngine; from src.data.models import BattingStats, PitchingStats; engine = SimulationEngine(); b = BattingStats('test', 2023, 'TEA', 100, 400, 50, 120, 20, 3, 15, 60, 0, 0, 40, 80, 2, 4, 0, 5); p = PitchingStats('test', 2023, 'TEA', 30, 30, 15, 10, 600, 180, 70, 60, 20, 50, 200, 5, 700, 5); result = engine.simulate_at_bat(b, p); print(result.outcome, result.runs_scored)"` - produces valid AtBatResult.
  </verify>
  <done>Simulation engine orchestrates all components and returns complete AtBatResult with probabilities and audit trail.</done>
</task>

<task type="auto">
  <name>Task 3: Create validation tests</name>
  <files>
    - tests/test_engine.py
    - tests/test_validation.py
  </files>
  <action>
Create integration tests and statistical validation.

In `tests/test_engine.py`:

1. `test_simulate_at_bat_returns_result()`:
   - Create mock stats, simulate at-bat
   - Result is AtBatResult with valid outcome

2. `test_simulate_at_bat_reproducible()`:
   - Same seed produces identical results
   - Create engine with seed=42, simulate 10 at-bats
   - Reset, simulate 10 more
   - Outcomes match exactly

3. `test_probabilities_returned()`:
   - Result includes probability dict
   - All expected keys present
   - Values between 0 and 1

4. `test_audit_trail_populated()`:
   - Result includes non-empty audit_trail
   - Contains tuples of RNG decisions

5. `test_get_expected_probabilities()`:
   - Returns probabilities without simulating
   - Sum approximately equals 1.0

6. `test_elite_pitcher_reduces_batting()`:
   - Elite pitcher (high K rate) vs average batter
   - Expected K rate higher than batter's historical K rate
   - This validates odds-ratio is working

In `tests/test_validation.py` (statistical validation):

1. `test_distribution_matches_historical()`:
   - Create batter with .300 BA, .250 OBP (approximately)
   - Simulate 1000 at-bats against league-average pitcher
   - Count hits, calculate simulated BA
   - Assert within 10% of expected (.270-.330)
   - This is the key validation from requirements

2. `test_elite_pitcher_dominates()`:
   - Elite pitcher (0.30 K rate) vs weak hitter (0.25 K rate)
   - Simulate 1000 at-bats
   - K rate should be > 0.275 (higher than naive average)
   - Elite should dominate, not average out

3. `test_home_run_rate_reasonable()`:
   - Power hitter (0.04 HR rate) vs average pitcher
   - Simulate 1000 at-bats
   - HR rate should be 0.03-0.05 (within variance)

4. `test_variance_not_collapsed()`:
   - Simulate same matchup 10 times with different seeds
   - Should get variety of outcomes (not identical)
   - At least 3 different outcome types observed

Note: Statistical tests use larger tolerance (10%) per requirements. Use pytest.approx or manual range checks.
  </action>
  <verify>
Run `pytest tests/test_engine.py tests/test_validation.py -v` - all tests pass.
  </verify>
  <done>Integration tests validate engine functionality. Statistical tests prove accuracy within 10% tolerance.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.simulation.engine import SimulationEngine; print('Import OK')"` - Engine importable
2. `pytest tests/test_engine.py -v` - Integration tests pass
3. `pytest tests/test_validation.py -v` - Statistical validation passes
4. Manual: Elite pitcher vs weak hitter produces elevated K rate (not naive average)
5. Manual: 1000-game simulation produces realistic batting averages
</verification>

<success_criteria>
- SimulationEngine orchestrates data loading, probability calculation, outcome resolution, and advancement
- AtBatResult includes outcome, advancement, probabilities, and audit trail
- Same seed produces identical simulation results
- Elite pitcher vs weak hitter produces appropriately skewed outcomes (not naive average)
- 1000-at-bat simulation produces statistics within 10% of historical rates
- Probabilities sum to approximately 1.0
- All integration and validation tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation-simulation-core/01-05-SUMMARY.md`
</output>
