---
phase: 01-data-foundation-simulation-core
plan: 03
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - src/simulation/rng.py
  - src/simulation/outcomes.py
  - src/simulation/at_bat.py
  - tests/test_at_bat.py
autonomous: true

must_haves:
  truths:
    - "At-bat simulation produces one of the defined outcome types"
    - "Same seed produces identical at-bat results (reproducible)"
    - "Outcome distribution matches input probabilities over many trials"
    - "Audit trail records random values and thresholds"
  artifacts:
    - path: "src/simulation/rng.py"
      provides: "Reproducible random number generator with audit trail"
      exports: ["SimulationRNG"]
    - path: "src/simulation/outcomes.py"
      provides: "AtBatOutcome enum with all outcome types"
      exports: ["AtBatOutcome"]
    - path: "src/simulation/at_bat.py"
      provides: "resolve_at_bat function using chained binomial"
      exports: ["resolve_at_bat", "calculate_conditional_probabilities"]
    - path: "tests/test_at_bat.py"
      provides: "Tests for outcome resolution"
      contains: "def test_"
  key_links:
    - from: "src/simulation/at_bat.py"
      to: "src/simulation/rng.py"
      via: "uses SimulationRNG for random decisions"
      pattern: "rng\\.random\\(\\)"
    - from: "src/simulation/at_bat.py"
      to: "src/simulation/outcomes.py"
      via: "returns AtBatOutcome enum"
      pattern: "AtBatOutcome\\."
---

<objective>
Implement at-bat outcome resolution using the chained binomial decision tree approach with reproducible randomness.

Purpose: This converts probability distributions into actual game outcomes while maintaining reproducibility for testing and audit trails.
Output: Function that takes matchup probabilities and returns a single outcome (strikeout, single, home run, etc.) with full audit capability.
</objective>

<execution_context>
@/home/fbasas/.claude/get-shit-done/workflows/execute-plan.md
@/home/fbasas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation-simulation-core/01-RESEARCH.md
@.planning/phases/01-data-foundation-simulation-core/01-02-SUMMARY.md (if exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RNG wrapper and outcome enum</name>
  <files>
    - src/simulation/rng.py
    - src/simulation/outcomes.py
  </files>
  <action>
Create reproducible RNG wrapper from RESEARCH.md Pattern 5.

In `src/simulation/rng.py`:

```python
import numpy as np
from typing import List, Tuple, Any

class SimulationRNG:
    """Wrapper for reproducible random number generation with audit trail."""

    def __init__(self, seed: int = None):
        self.seed = seed
        self.rng = np.random.default_rng(seed)
        self.history: List[Tuple] = []

    def random(self) -> float:
        """Generate random float [0, 1) with audit logging."""
        value = float(self.rng.random())
        self.history.append(('random', value))
        return value

    def choice(self, options: List[Any], probabilities: List[float]) -> Any:
        """Weighted random choice with logging."""
        result = self.rng.choice(options, p=probabilities)
        self.history.append(('choice', result, dict(zip(map(str, options), probabilities))))
        return result

    def get_audit_trail(self) -> List[Tuple]:
        """Return copy of random decision history."""
        return self.history.copy()

    def reset(self, seed: int = None):
        """Reset RNG state and clear history."""
        self.seed = seed if seed is not None else self.seed
        self.rng = np.random.default_rng(self.seed)
        self.history = []
```

In `src/simulation/outcomes.py`:

Create `AtBatOutcome` enum covering all outcome types from CONTEXT.md:

```python
from enum import Enum, auto

class AtBatOutcome(Enum):
    # Plate appearance without contact
    STRIKEOUT_SWINGING = auto()  # K
    STRIKEOUT_LOOKING = auto()   # Kc
    WALK = auto()
    HIT_BY_PITCH = auto()

    # Hits
    SINGLE = auto()
    DOUBLE = auto()
    TRIPLE = auto()
    HOME_RUN = auto()
    INFIELD_SINGLE = auto()  # Distinct from outfield single

    # Batted ball outs
    GROUNDOUT = auto()
    FLYOUT = auto()
    LINEOUT = auto()
    POPUP = auto()           # Infield fly
    FOUL_OUT = auto()

    # Special outcomes
    REACHED_ON_ERROR = auto()
    SACRIFICE_FLY = auto()
    SACRIFICE_HIT = auto()   # Sac bunt - deferred but enum ready
    GIDP = auto()            # Ground into double play
    FIELD_CHOICE = auto()    # Fielder's choice (runner out)

    @property
    def is_hit(self) -> bool:
        return self in (
            AtBatOutcome.SINGLE, AtBatOutcome.DOUBLE,
            AtBatOutcome.TRIPLE, AtBatOutcome.HOME_RUN,
            AtBatOutcome.INFIELD_SINGLE
        )

    @property
    def is_out(self) -> bool:
        return self in (
            AtBatOutcome.STRIKEOUT_SWINGING, AtBatOutcome.STRIKEOUT_LOOKING,
            AtBatOutcome.GROUNDOUT, AtBatOutcome.FLYOUT,
            AtBatOutcome.LINEOUT, AtBatOutcome.POPUP, AtBatOutcome.FOUL_OUT,
            AtBatOutcome.SACRIFICE_FLY, AtBatOutcome.SACRIFICE_HIT,
            AtBatOutcome.GIDP, AtBatOutcome.FIELD_CHOICE
        )

    @property
    def is_on_base(self) -> bool:
        return self in (
            AtBatOutcome.SINGLE, AtBatOutcome.DOUBLE,
            AtBatOutcome.TRIPLE, AtBatOutcome.INFIELD_SINGLE,
            AtBatOutcome.WALK, AtBatOutcome.HIT_BY_PITCH,
            AtBatOutcome.REACHED_ON_ERROR
        )

    @property
    def bases_gained(self) -> int:
        """How many bases the batter reaches (0 for outs, 4 for HR)."""
        mapping = {
            AtBatOutcome.SINGLE: 1, AtBatOutcome.INFIELD_SINGLE: 1,
            AtBatOutcome.DOUBLE: 2, AtBatOutcome.TRIPLE: 3,
            AtBatOutcome.HOME_RUN: 4,
            AtBatOutcome.WALK: 1, AtBatOutcome.HIT_BY_PITCH: 1,
            AtBatOutcome.REACHED_ON_ERROR: 1,
        }
        return mapping.get(self, 0)
```
  </action>
  <verify>
Run `python -c "from src.simulation.rng import SimulationRNG; from src.simulation.outcomes import AtBatOutcome; print(AtBatOutcome.HOME_RUN.is_hit, AtBatOutcome.GROUNDOUT.is_out)"` shows True True.
  </verify>
  <done>RNG wrapper supports seeding and audit trails. AtBatOutcome enum covers all outcome types with helper properties.</done>
</task>

<task type="auto">
  <name>Task 2: Implement chained binomial at-bat resolution</name>
  <files>src/simulation/at_bat.py</files>
  <action>
Implement the chained binomial decision tree from RESEARCH.md Pattern 3.

The key insight: odds-ratio gives us probabilities for each event type, but they're not conditional. We need to chain binary decisions to ensure probabilities sum to 1.

Decision tree structure:
1. Hit by pitch? (rare, check first)
2. Walk?
3. Contact made? (no = strikeout, split K vs Kc)
4. Home run? (given contact)
5. Hit? (given contact, not HR)
6. Extra base hit? (given hit, not HR)
7. Triple? (given extra base hit)
8. Out type? (groundout, flyout, lineout, popup)
9. Special outcomes (error, GIDP, sac fly based on situation)

Create functions:

1. `calculate_conditional_probabilities(matchup_probs: dict, game_situation: dict = None) -> dict`
   - Convert matchup probabilities to conditional probabilities for decision tree
   - matchup_probs has: strikeout, walk, hbp, single, double, triple, home_run
   - game_situation (optional): outs, runners_on (for GIDP, sac fly eligibility)
   - Returns dict with conditional probs for each decision point

2. `resolve_at_bat(conditional_probs: dict, rng: SimulationRNG, game_situation: dict = None) -> AtBatOutcome`
   - Walk through decision tree using RNG
   - Each decision: `if rng.random() < probability: ...`
   - Return the resulting AtBatOutcome

3. Helper `determine_out_type(rng: SimulationRNG, game_situation: dict = None) -> AtBatOutcome`
   - Given ball in play resulted in out, determine type
   - League averages: groundout ~44%, flyout ~28%, lineout ~21%, popup ~7%
   - If runners on first with < 2 outs, small chance of GIDP
   - If runner on third with < 2 outs, flyout may become sacrifice fly

Decision tree implementation:
```python
def resolve_at_bat(cond_probs, rng, situation=None):
    # 1. Hit by pitch
    if rng.random() < cond_probs['hbp']:
        return AtBatOutcome.HIT_BY_PITCH

    # 2. Walk
    if rng.random() < cond_probs['walk']:
        return AtBatOutcome.WALK

    # 3. Strikeout (no contact)
    if rng.random() < cond_probs['strikeout']:
        # 70% swinging, 30% looking (approximate)
        if rng.random() < 0.70:
            return AtBatOutcome.STRIKEOUT_SWINGING
        return AtBatOutcome.STRIKEOUT_LOOKING

    # Contact was made - now determine outcome
    # 4. Home run (given contact)
    if rng.random() < cond_probs['home_run_given_contact']:
        return AtBatOutcome.HOME_RUN

    # 5. Hit vs out (given non-HR contact)
    if rng.random() < cond_probs['hit_given_non_hr_contact']:
        # 6. Extra base hit (given hit)
        if rng.random() < cond_probs['extra_base_given_hit']:
            # 7. Triple vs double
            if rng.random() < cond_probs['triple_given_extra_base']:
                return AtBatOutcome.TRIPLE
            return AtBatOutcome.DOUBLE

        # Single - small chance of infield single
        if rng.random() < 0.15:  # ~15% of singles are infield
            return AtBatOutcome.INFIELD_SINGLE
        return AtBatOutcome.SINGLE

    # Out on batted ball - determine type
    return determine_out_type(rng, situation)
```

Note: GIDP, sacrifice fly, and error logic can be simplified for now - full situational awareness comes in Phase 2.
  </action>
  <verify>
Run `python -c "from src.simulation.at_bat import resolve_at_bat, calculate_conditional_probabilities; from src.simulation.rng import SimulationRNG; probs = {'strikeout': 0.20, 'walk': 0.08, 'hbp': 0.01, 'single': 0.15, 'double': 0.04, 'triple': 0.005, 'home_run': 0.03}; cond = calculate_conditional_probabilities(probs); rng = SimulationRNG(42); print(resolve_at_bat(cond, rng))"` - produces a valid AtBatOutcome.
  </verify>
  <done>Chained binomial decision tree resolves matchup probabilities into specific outcomes.</done>
</task>

<task type="auto">
  <name>Task 3: Create at-bat resolution tests</name>
  <files>tests/test_at_bat.py</files>
  <action>
Create tests validating at-bat resolution correctness.

Test cases:

1. `test_resolve_at_bat_returns_valid_outcome()`:
   - Call resolve_at_bat with sample probabilities
   - Result is an AtBatOutcome enum value

2. `test_resolve_at_bat_reproducible_with_seed()`:
   - Same seed produces identical sequence of outcomes
   - Call 10 times with seed=42, record outcomes
   - Reset, call 10 more times with seed=42
   - Sequences should match exactly

3. `test_audit_trail_records_decisions()`:
   - After resolve_at_bat, rng.get_audit_trail() is non-empty
   - Trail contains ('random', value) tuples

4. `test_distribution_matches_probabilities()`:
   - Run 10,000 at-bats with known probabilities
   - Count outcome frequencies
   - Strikeout rate should be within 2% of input probability
   - Home run rate should be within 1% of input probability
   - This is a statistical test - use reasonable tolerances

5. `test_all_outcomes_possible()`:
   - With non-zero probabilities for all events
   - Run enough trials that each outcome type appears at least once
   - (Or explicitly test edge cases for each outcome)

6. `test_conditional_probabilities_sum_correctly()`:
   - calculate_conditional_probabilities output
   - At each decision level, probabilities make sense (0-1 range)
   - P(hit given non-HR contact) + P(out given non-HR contact) should implicitly = 1

7. `test_home_run_is_hit()`:
   - AtBatOutcome.HOME_RUN.is_hit == True
   - AtBatOutcome.HOME_RUN.bases_gained == 4

8. `test_strikeout_is_out()`:
   - AtBatOutcome.STRIKEOUT_SWINGING.is_out == True
   - AtBatOutcome.STRIKEOUT_SWINGING.is_on_base == False

Use pytest fixtures for common setup (sample probabilities, RNG with seed).
  </action>
  <verify>
Run `pytest tests/test_at_bat.py -v` - all tests pass.
  </verify>
  <done>At-bat resolution tests validate reproducibility, distribution accuracy, and outcome properties.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.simulation import rng, outcomes, at_bat; print('Imports OK')"` - All modules importable
2. `pytest tests/test_at_bat.py -v` - All tests pass
3. Manual: Run 1000 at-bats with modern league averages, verify K rate ~21%, HR rate ~3%
4. Manual: Same seed produces identical at-bat sequence
</verification>

<success_criteria>
- SimulationRNG supports seeding and produces identical sequences with same seed
- Audit trail captures all random decisions
- AtBatOutcome enum covers all outcomes from CONTEXT.md
- Outcome properties (is_hit, is_out, bases_gained) work correctly
- Chained binomial produces outcomes matching input probability distributions
- Distribution test passes with reasonable tolerance (~2% for common events)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation-simulation-core/01-03-SUMMARY.md`
</output>
